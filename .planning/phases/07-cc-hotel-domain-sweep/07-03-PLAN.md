---
phase: 07-cc-hotel-domain-sweep
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - workflows/discover_owners.py
autonomous: false

must_haves:
  truths:
    - "Running `uv run python3 workflows/discover_owners.py --source big4 --dry-run` shows hotel and domain counts without processing"
    - "Running `uv run python3 workflows/discover_owners.py --source big4 --audit` shows coverage stats for owner discovery"
    - "Running `uv run python3 workflows/discover_owners.py --source big4 --apply --limit 10` processes 10 hotels through the full CC pipeline and persists results"
    - "The CLI matches the enrich_contacts.py pattern: --source, --limit, --apply, --audit, --dry-run, -v"
    - "Results are persisted incrementally (crash at hotel 900 preserves first 880)"
  artifacts:
    - path: "workflows/discover_owners.py"
      provides: "Complete CC owner discovery CLI with audit, dry-run, apply modes"
      contains: "if __name__"
      exports: ["main"]
  key_links:
    - from: "workflows/discover_owners.py (CLI)"
      to: "workflows/discover_owners.py (discover_owners_cc)"
      via: "main() dispatches to discover_owners_cc() or audit()"
      pattern: "await discover_owners_cc"
    - from: "workflows/discover_owners.py (audit)"
      to: "sadie_gtm.hotel_decision_makers"
      via: "SQL count queries"
      pattern: "hotel_decision_makers"
---

<objective>
Add the CLI entrypoint and audit command to complete the discover_owners.py workflow, then verify end-to-end operation.

Purpose: Without the CLI, the pipeline functions cannot be invoked. The CLI must match the enrich_contacts.py pattern (--source, --limit, --apply, --audit, --dry-run) so the user has a consistent interface. The audit command shows coverage stats to measure pipeline effectiveness.

Output: Complete `workflows/discover_owners.py` that can be run from the command line. End-to-end verification with a small batch.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-cc-hotel-domain-sweep/07-RESEARCH.md
@.planning/phases/07-cc-hotel-domain-sweep/07-02-SUMMARY.md

# Source files:
@workflows/enrich_contacts.py
@workflows/discover_owners.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add audit function and CLI entrypoint</name>
  <files>workflows/discover_owners.py</files>
  <action>
Add the `audit()` function and `main()` CLI entrypoint to `discover_owners.py`, following the pattern from `enrich_contacts.py` lines 1680-1797.

**1. Audit function:**

```python
async def audit(args, cfg: dict):
    """Show coverage stats for owner discovery."""
    jc = cfg.get("join") or ""
    wc = cfg["where"]

    conn = await asyncpg.connect(**DB_CONFIG)

    # Total hotels in source
    total = await conn.fetchval(
        f"SELECT COUNT(*) FROM sadie_gtm.hotels h {jc} WHERE ({wc})"
    )

    # Hotels with website
    with_website = await conn.fetchval(
        f"SELECT COUNT(*) FROM sadie_gtm.hotels h {jc}"
        f" WHERE ({wc}) AND h.website IS NOT NULL AND h.website != ''"
    )

    # Hotels with at least one decision maker
    with_dm = await conn.fetchval(
        f"SELECT COUNT(DISTINCT h.id) FROM sadie_gtm.hotels h {jc}"
        f" JOIN sadie_gtm.hotel_decision_makers dm ON dm.hotel_id = h.id"
        f" WHERE ({wc})"
    )

    # Total decision makers
    total_dms = await conn.fetchval(
        f"SELECT COUNT(*) FROM sadie_gtm.hotel_decision_makers dm"
        f" JOIN sadie_gtm.hotels h ON h.id = dm.hotel_id {jc}"
        f" WHERE ({wc})"
    )

    # Decision makers by source
    sources = await conn.fetch(
        f"SELECT s AS src, COUNT(*) AS cnt"
        f" FROM sadie_gtm.hotel_decision_makers dm"
        f" JOIN sadie_gtm.hotels h ON h.id = dm.hotel_id {jc},"
        f" LATERAL unnest(dm.sources) AS s"
        f" WHERE ({wc})"
        f" GROUP BY s ORDER BY cnt DESC"
    )

    # Hotels with enrichment status (CC sweep attempted)
    enriched = await conn.fetchval(
        f"SELECT COUNT(*) FROM sadie_gtm.hotel_owner_enrichment oe"
        f" JOIN sadie_gtm.hotels h ON h.id = oe.hotel_id {jc}"
        f" WHERE ({wc})"
    )

    # DMs with vs without email
    with_email = await conn.fetchval(
        f"SELECT COUNT(*) FROM sadie_gtm.hotel_decision_makers dm"
        f" JOIN sadie_gtm.hotels h ON h.id = dm.hotel_id {jc}"
        f" WHERE ({wc}) AND dm.email IS NOT NULL AND dm.email != ''"
    )

    print(f"\n{'='*60}")
    print(f"Owner Discovery Audit: {cfg['label']}")
    print(f"{'='*60}")
    print(f"  Hotels total:          {total:>6}")
    print(f"  Hotels with website:   {with_website:>6}  ({100*with_website/max(total,1):.0f}%)")
    print(f"  Hotels enriched (any): {enriched:>6}  ({100*enriched/max(total,1):.0f}%)")
    print(f"  Hotels with DM found:  {with_dm:>6}  ({100*with_dm/max(total,1):.0f}%)")
    print(f"")
    print(f"  Decision makers total: {total_dms:>6}")
    print(f"  DMs with email:        {with_email:>6}  ({100*with_email/max(total_dms,1):.0f}%)")
    print(f"  DMs without email:     {total_dms - with_email:>6}")
    print(f"")
    print(f"  Sources:")
    for r in sources:
        print(f"    {r['src']:<30} {r['cnt']:>5}")

    if args.verbose:
        # Sample DMs found via CC
        samples = await conn.fetch(
            f"SELECT dm.full_name, dm.title, h.name AS hotel_name,"
            f" dm.sources, dm.confidence"
            f" FROM sadie_gtm.hotel_decision_makers dm"
            f" JOIN sadie_gtm.hotels h ON h.id = dm.hotel_id {jc}"
            f" WHERE ({wc}) AND dm.sources && ARRAY['cc_website_llm', 'cc_website_regex', 'cc_website_jsonld']"
            f" ORDER BY dm.created_at DESC LIMIT 20"
        )
        if samples:
            print(f"\n  Recent CC-discovered DMs:")
            for r in samples:
                src = ', '.join(r['sources']) if r['sources'] else '?'
                print(f"    {r['full_name']:30s} | {(r['title'] or ''):25s} | {r['hotel_name'][:30]:30s} | {src}")

    await conn.close()
```

**2. CLI entrypoint -- `main()`:**

Follow the exact pattern from `enrich_contacts.py` lines 1742-1797:

```python
async def main():
    parser = argparse.ArgumentParser(
        description="Owner discovery via Common Crawl â€” find hotel owners, GMs, and decision makers",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=f"Available sources: {', '.join(SOURCE_CONFIGS.keys())}, custom",
    )
    parser.add_argument("--source", required=True,
                        help=f"Source config: {', '.join(SOURCE_CONFIGS.keys())}, or 'custom'")
    parser.add_argument("--where", type=str, default=None,
                        help="Custom WHERE clause (for --source custom)")
    parser.add_argument("--audit", action="store_true",
                        help="Print owner discovery coverage stats")
    parser.add_argument("--apply", action="store_true",
                        help="Write results to DB (default: dry-run mode)")
    parser.add_argument("--dry-run", action="store_true",
                        help="Show what would be processed without fetching")
    parser.add_argument("--limit", type=int, default=None,
                        help="Max hotels to process")
    parser.add_argument("-v", "--verbose", action="store_true")

    args = parser.parse_args()

    logger.remove()
    logger.add(sys.stderr, level="DEBUG" if args.verbose else "INFO")

    if args.source == "custom":
        if not args.where:
            print("ERROR: --source custom requires --where")
            sys.exit(1)
        cfg = {
            "label": "Custom",
            "where": args.where,
            "join": None,
            "country": "AU",
        }
    elif args.source in SOURCE_CONFIGS:
        cfg = SOURCE_CONFIGS[args.source]
    else:
        print(f"ERROR: Unknown source '{args.source}'. "
              f"Available: {', '.join(SOURCE_CONFIGS.keys())}, custom")
        sys.exit(1)

    logger.info(f"Source: {cfg['label']}")

    if args.audit:
        await audit(args, cfg)
    else:
        stats = await discover_owners_cc(args, cfg)
        if not args.dry_run and not args.apply:
            print(f"\nDry-run complete. {stats.get('owners_extracted', 0)} owners found. "
                  f"Run with --apply to write to DB.")


if __name__ == "__main__":
    asyncio.run(main())
```

IMPORTANT behaviors:
- Without `--apply`, the pipeline runs fully (CC harvest + extraction) but does NOT write to DB. It shows results and prompts to re-run with `--apply`. This is the default "safe" mode.
- With `--dry-run`, the pipeline does NOT fetch from CC at all. It only loads hotels and shows counts.
- With `--apply`, results are written to DB incrementally.
- With `--audit`, only coverage stats are shown (no processing).
  </action>
  <verify>
1. `uv run python3 workflows/discover_owners.py --help` shows usage with --source, --audit, --apply, --dry-run, --limit, -v
2. `uv run python3 workflows/discover_owners.py --source big4 --dry-run` shows hotel/domain counts without processing
3. `uv run python3 workflows/discover_owners.py --source big4 --audit` shows coverage stats
  </verify>
  <done>CLI entrypoint works with all flags (--source, --limit, --apply, --audit, --dry-run, -v). Audit command shows coverage stats. Dry-run shows counts without processing. Default mode (no --apply) runs pipeline but does not persist.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete CC owner discovery pipeline: CC Index query -> WARC fetch -> JSON-LD/regex/LLM extraction -> incremental persistence -> CLI</what-built>
  <how-to-verify>
1. Run dry-run to check hotel counts:
   ```
   uv run python3 workflows/discover_owners.py --source big4 --dry-run
   ```
   Expected: Shows hotel count, domain count, CC query count

2. Run audit to check current state:
   ```
   uv run python3 workflows/discover_owners.py --source big4 --audit
   ```
   Expected: Shows hotels total, hotels with DMs, source breakdown

3. Run small batch WITHOUT --apply to test full pipeline:
   ```
   uv run python3 workflows/discover_owners.py --source big4 --limit 5 -v
   ```
   Expected: CC harvest runs, pages fetched, owners extracted, shows stats but says "Run with --apply to write to DB"

4. Run small batch WITH --apply to test persistence:
   ```
   uv run python3 workflows/discover_owners.py --source big4 --limit 5 --apply -v
   ```
   Expected: Same as above but "Flushed N hotels to DB" messages appear, owners saved count > 0

5. Re-run audit to confirm data was saved:
   ```
   uv run python3 workflows/discover_owners.py --source big4 --audit -v
   ```
   Expected: DM count increased, cc_website_llm or cc_website_jsonld or cc_website_regex appears in sources
  </how-to-verify>
  <resume-signal>Type "approved" if pipeline works end-to-end, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. `uv run python3 workflows/discover_owners.py --help` exits 0 and shows all expected flags
2. `uv run python3 workflows/discover_owners.py --source big4 --dry-run` exits 0 and shows counts
3. `uv run python3 workflows/discover_owners.py --source big4 --audit` exits 0 and shows stats
4. `uv run python3 workflows/discover_owners.py --source big4 --limit 5 --apply -v` exits 0 and saves DMs to DB
5. After `--apply` run, re-running `--audit` shows increased DM count with cc_website_* sources
</verification>

<success_criteria>
- CLI matches enrich_contacts.py pattern (--source, --limit, --apply, --audit, --dry-run)
- End-to-end pipeline works: CC harvest -> three-tier extraction -> incremental DB persistence
- Audit shows coverage stats including source breakdown
- Small batch (--limit 5) completes successfully with --apply
- Results appear in hotel_decision_makers with cc_website_* source tags
</success_criteria>

<output>
After completion, create `.planning/phases/07-cc-hotel-domain-sweep/07-03-SUMMARY.md`
</output>
